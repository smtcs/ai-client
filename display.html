<!doctype html>
<html lang="en" ng-app>

<head>
  <script src="/socket.io/socket.io.js"></script>

  <title>Chat Example</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      padding-top: 60px;
    }

    canvas {
      border: 3px solid #d3d3d3;
      position: absolute;
      top: 0px;
      left: 0px;
    }
    
.slider {
    -webkit-appearance: none;
    width: 100%;
    background: #7c7c7c;
    height: 4px;
    outline: none;
    cursor: pointer;
}

.slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 100%;
    background: #ff2828;
    cursor: pointer;
}
    
  </style>

</head>

<body>



<div id = "winner" style = "font-weight: bold; font-size: 150%; background: white;z-index: 2; position: absolute; text-align: center; border: 1px solid; display: none; padding: auto; margin: 100px; ">
</div>

<h1 style = "position: absolute; top: -10px; left: 40%;">Vindinium</h1>
  <canvas id="canvas" width="600px" height="600px" style="position: relative;"></canvas>
  

  
<button id = "watchlive" style = "position: absolute;top: 676px; left: 150px; display: none;">Watch live games</button>
<input type="range" min="0" max="200" value="0" id="time" style = "display: none;position: absolute; top: 653px; left: 9px; float: left; width: 600px; padding: 0px; z-index: 100000;" class = "slider"></input>
<input id = "speed" type = "range" min = "4" max = "300" value = "254" style = "position: absolute; top:  676px; left: 7px;float: left; display: none;"></input>
<div style = "position: absolute; top: 711px; border: 1px solid;"id = "names">
  
  
  </div>

  <div style="display: none;">
    <img src = "imgs/onair.png" id = "live"/>
    
    
    <img src="imgs/redbackwards.png" id="rednorth" />
    <img src="imgs/redforwards.png" id="redsouth" />
    <img src="imgs/redright.png" id="redeast" />
    <img src="imgs/redleft.png" id="redwest" />

    <img src="imgs/bluebackwards.png" id="bluenorth" />
    <img src="imgs/blueforwards.png" id="bluesouth" />
    <img src="imgs/blueright.png" id="blueeast" />
    <img src="imgs/blueleft.png" id="bluewest" />

    <img src="imgs/greybackwards.png" id="greynorth" />
    <img src="imgs/greyforwards.png" id="greysouth" />
    <img src="imgs/greyright.png" id="greyeast" />
    <img src="imgs/greyleft.png" id="greywest" />

    <img src="imgs/yellowbackwards.png" id="yellownorth" />
    <img src="imgs/yellowforwards.png" id="yellowsouth" />
    <img src="imgs/yellowright.png" id="yelloweast" />
    <img src="imgs/yellowleft.png" id="yellowwest" />
  </div>
  <div style="position: absolute; top: 100px; left: 75%;">
    <input id="username"></input>
    <button id="create">Create a bot</button>
    <div id="after"></div>
    <div id="scoreboard" style="display: inline-block;">
      <p id = "turnStr"></p>
      <select id="selectGame">
  <option value="0">Game 1</option>
  <option value="1">Game 2</option>
  <option value="2">Game 3</option>
  <option value="3">Game 4</option>
    <option value="4">Game 5</option>
</select>
<br>
      <div id = "player0" style = "border: 7px solid; display: inline-block; padding: 5px; border-color: red;"></div>
 
<br>
<div id = "player1" style = "border: 7px solid; display: inline-block; padding: 5px; border-color: #2172ff; "></div>
<br>
<div id= "player2" style = "border:7px solid; display: inline-block; padding: 5px; border-color: #ffcc00; "></div>
<br>
<div id = "player3" style = "border: 7px solid; display: inline-block; padding: 5px; border-color: grey; "></div>
    </div>

  </div>
  <script src="/js/jquery.min.js"></script>
  <script>
  const key = Math.random().toString(36).substr(2, 35); //"Render" the key immediately so it can't be modified through console.
  var rerunArrLength = 0;
  var rerunObj;
  var lastCoords;
    var barricades = [];
    var socket = io.connect();
    let winText =  document.getElementById("winner");
    var btn = document.getElementById("create");
    var username = document.getElementById("username");
    var after = document.getElementById("after");
    var watchlive = document.getElementById("watchlive");
    btn.onclick = function() {
      btn.style.display = "none";
      username.style.display = "none";
      after.innerHTML = "Note: If another player has the username you entered, your bot will not work.<br>Username: " + username.value + "<br>Bot Key: " + key + "<br><br>";
      socket.emit("newPlayer", { "key": key, "username": username.value })
    }


    var playerImgs = {
      rednorth: document.getElementById("rednorth"),
      redsouth: document.getElementById("redsouth"),
      redeast: document.getElementById("redeast"),
      redwest: document.getElementById("redwest"),
      bluenorth: document.getElementById("bluenorth"),
      bluesouth: document.getElementById("bluesouth"),
      blueeast: document.getElementById("blueeast"),
      bluewest: document.getElementById("bluewest"),
      greynorth: document.getElementById("greynorth"),
      greysouth: document.getElementById("greysouth"),
      greyeast: document.getElementById("greyeast"),
      greywest: document.getElementById("greywest"),
      yellownorth: document.getElementById("yellownorth"),
      yellowsouth: document.getElementById("yellowsouth"),
      yelloweast: document.getElementById("yelloweast"),
      yellowwest: document.getElementById("yellowwest")
    }

    socket.emit("display");
    var game;
    var rollbacking = false;
    var canvas = document.getElementById("canvas");
    var ctx = canvas.getContext("2d")
    var size = 20;
    var xSize = canvas.width / size;
    var ySize = canvas.height / size;

    ctx.fillStyle = "black";

    function drawGrid() {
      ctx.beginPath();
      for (let x = 0; x <= canvas.width; x += xSize) {
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y <= canvas.width; y += ySize) {
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
    }

    function show(gameToDraw) {

      for (var i = 0; i < gameToDraw.barricades.length; i++) {
        ctx.fillStyle = "pink";
        ctx.fillRect(gameToDraw.barricades[i][0] * xSize, gameToDraw.barricades[i][1] * ySize, xSize, ySize)
      }
      
for(let i=0;i<gameToDraw.players.length;i++) {
  if(!(gameToDraw.players[i].dir== "south" || gameToDraw.players[i].dir== "north" ||gameToDraw.players[i].dir== "east" || gameToDraw.players[i].dir== "west"  )){
    gameToDraw.players[i].dir = "south";
  }
        ctx.drawImage(playerImgs[gameToDraw.players[i].color + gameToDraw.players[i].dir], gameToDraw.players[i].pos[0] * xSize, gameToDraw.players[i].pos[1] * ySize, xSize, ySize);

    
  }

    }

    function bases(game) {
      ctx.fillStyle = game.players[game.idTurn].color;

      ctx.fillRect(game.bases[game.idTurn].pos[0] * xSize, game.bases[game.idTurn].pos[1] * ySize, xSize, ySize);

      ctx.font = "20px Arial";

      for (var i = 0; i < game.bases.length; i++) {
        ctx.fillStyle = "white"
        ctx.fillText(game.bases[i].energy, game.bases[i].pos[0] * xSize, (game.bases[i].pos[1] * ySize) + ySize);
      }


    }

    function nodes(loopArr) {
      for (var i = 0; i < loopArr.length; i++) {
        ctx.fillStyle = "purple";
        ctx.fillRect(loopArr[i].pos[0] * xSize, loopArr[i].pos[1] * ySize, xSize, ySize);
        ctx.font = "20px Arial";
        ctx.fillStyle = "white"
        ctx.fillText(loopArr[i].energy, loopArr[i].pos[0] * xSize, (loopArr[i].pos[1] * ySize) + ySize);
      }
    }

    function clear(x, y) {
      ctx.fillStyle = "white";
      ctx.fillRect(((x) * xSize), ((y) * ySize), xSize, ySize);
      ctx.fillStyle = "black";
      ctx.strokeStyle = "black";
      ctx.lineWidth = 1.5;
      ctx.strokeRect((x) * xSize, (y) * ySize, xSize, ySize);
    }
    var games;
    drawGrid();
      let rerunLoop;
          let ind = 0;
      var time = document.getElementById("time");
      document.getElementById("speed").oninput = function(){
 clearInterval(rerunLoop);
 rerunLoop =  setInterval(loop,304 - document.getElementById("speed").value);
     }
      
      
      time.oninput = function() { changeTime(time.value); };
      function changeTime(newTime, intTime){ //In order to not have to save energy states in the replay.JSON database, for rollbacks I have to start from turn 0 and simulate the game up to where the user wants to rollback to.
     if(newTime < rerunObj.turns.length-1){
       winText.style.display = "none";
       winText.innerHTML = "";
     }
     
     
        clearInterval(rerunLoop);
        //time.value = tempNum;
        for(var k = 0;k<rerunObj.players.length;k++){
          try{
          clear(rerunObj.players[k].pos[0],rerunObj.players[k].pos[1]);
          rerunObj.players[k].energy = 0;
          }catch(err){
          }
        }
        //Setting ind to 0 and setting all bases, node, and player energy to 0 to initiate the simulation.
         ind = 0;
        for(var i=0;i<rerunObj.map.nodes.length;i++){
          rerunObj.map.nodes[i].energy = 0;
        }
        for(var j=0;j<rerunObj.map.bases.length;j++){
          rerunObj.map.bases[j].energy = 0;
        }
        for(let i=0;i<newTime;i++){
          loop(true);
        }
        ind = newTime;
          rerunLoop  = setInterval(function(){loop(false);}, 304 -  document.getElementById("speed").value);
      
        
      }
      watchlive.onclick = function(){
        clearInterval(rerunLoop);
        ind = 0;
    ctx.fillStyle = "white"; // clearing canvas
    ctx.fillRect(0,0,600,600);
    drawGrid();
    rollbacking = false;
    winText.style.display = "none";
    watchlive.style.display = "none";
    time.style.display = "none";
    selectGame.style.display = "block";
    document.getElementById("speed").style.display = "none";
      }

      
  socket.on("rerunGameData", function(data){
    document.documentElement.scrollTop = 53;
    winText.style.display = "none";
    winText.innerHTML = "";
    selectGame.style.display = "none";
    rollbacking = true;
    watchlive.style.display = "block";
    time.style.display = "block";
    document.getElementById("speed").style.display = "block";
    clearInterval(rerunLoop); //Stops reruns that are currently running to initiate this one.
    rerunObj = data; //Global variable.
    ind = 0; //On top of resetting any other games running, we need to set the ind to 0.
    ctx.fillStyle = "white"; // clearing canvas
    ctx.fillRect(0,0,600,600);
    drawGrid();
    time.max = rerunObj.turns.length-1; //for rollbacking, set the max value of the time slider to the number of turns.
    rerunLoop  = setInterval(loop, 304 - document.getElementById("speed").value); //initiates game rollback.
  })
     function loop(isRerunning) {
      rerunObj.players[ind % rerunObj.players.length].pos = rerunObj.turns[ind];
     

      
          if(ind > rerunObj.players.length-1){
        clear(rerunObj.turns[ind-rerunObj.players.length][0],rerunObj.turns[(ind-rerunObj.players.length)][1])
      }
      
      
    if(!isRerunning){  
      time.value = ind;
    }
    
        if (ind % 3 == 0) {
        for (var i = 0; i < rerunObj.map.nodes.length; i++) {
          rerunObj.map.nodes[i].energy++;
        }
      }
    
      checkNodes(rerunObj.players[ind % rerunObj.players.length], rerunObj.map.nodes)

          checkCollide(rerunObj.players, rerunObj.map.bases)
          checkBase(rerunObj.players,rerunObj.map.bases)
          let tempTurn = 0;
          if(ind > rerunObj.turns.length-rerunObj.players.length){
            tempTurn = rerunObj.turns.length-rerunObj.players.length;
          } else{
            tempTurn = ind;
          }
         scoreboard(rerunObj.players, rerunObj.map.bases, (tempTurn) +"/" + (rerunObj.turns.length-rerunObj.players.length) )
    nodes(rerunObj.map.nodes)
 
      for (var i = 0; i < rerunObj.map.barricades.length; i++) {
        ctx.fillStyle = "pink"
        ctx.fillRect(rerunObj.map.barricades[i][0] * xSize, rerunObj.map.barricades[i][1] * ySize, xSize, ySize)
        
      }
            if(ind > rerunObj.players.length){
      for(let i=0;i<rerunObj.players.length;i++){
      
      ctx.fillStyle = rerunObj.players[i].color;
      ctx.fillRect(rerunObj.map.bases[i].pos[0] * xSize,rerunObj.map.bases[i].pos[1] * ySize,xSize,ySize)
       
      ctx.font = "20px Arial";
        ctx.fillStyle = "white"
        ctx.fillText(rerunObj.map.bases[i].energy, rerunObj.map.bases[i].pos[0] * xSize, (rerunObj.map.bases[i].pos[1] * ySize) + ySize);
}
}

      if(rerunObj.players[ind% rerunObj.players.length].dir == "" ||rerunObj.players[ind% rerunObj.players.length].dir == null  ){
        rerunObj.players[ind% rerunObj.players.length].dir = "south"
      }
      if(ind > rerunObj.players.length){
      for(let i=0;i<rerunObj.players.length;i++){
       ctx.drawImage(playerImgs[rerunObj.players[i].color + rerunObj.players[i].dir], rerunObj.players[i].pos[0] * xSize, rerunObj.players[i].pos[1] * ySize, xSize, ySize);
      }
      }
      
      
      
      
      ind++;
      if(ind >= rerunObj.turns.length){
        if(rerunObj.winnerId == "tie"){
                winText.style.display = "inline-block";
      winText.innerHTML = "Tie!<br>Better luck next time!";
        } else{
        displayWinner(rerunObj.players[rerunObj.winnerId].color,rerunObj.players[rerunObj.winnerId].name,rerunObj.map.bases[rerunObj.winnerId].energy, rerunObj.winnerId);
        clearInterval(rerunLoop);
      }
      }
}
    socket.on("replayNames", function(stringArr){
      rerunArrLength = JSON.parse(JSON.stringify(stringArr.length));
        let p;
    for(var i=stringArr.length-1;i>=0;i--){
      p = document.createElement("P");
    p.innerHTML = i+1 +". " +stringArr[i];
    p.onclick = function(){
      socket.emit("rerunGame", parseInt(this.innerHTML.substring(0,this.innerHTML.indexOf(".")))-1);
    }
         document.getElementById("names").appendChild(p);
    }    
    })
    socket.on("queue", function(data) {
      games = data;
      if(!rollbacking){
      for (var i = 0; i < data.length; i++) {
        if (data[i].running) {
                       ctx.fillStyle = "white";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      drawGrid();
          game = data[i];
          break;
        
        }
        }
      }

    })
    let changeColor = 
   socket.on("endGame", function(obj){
     if(!rollbacking){
     if(games[parseInt(selectGame.options[selectGame.selectedIndex].value)].gameId == obj.gameId ){
   if(obj.winner == "tie"){
      winText.style.display = "inline-block";
      winText.innerHTML = "Tie!<br>Better luck next time!";
   } else{
displayWinner(obj.winner.color, obj.winner.name, obj.base.energy, obj.winner.id);
   }
   
   for(let i=0;i<games.length;i++){
     if(games[i].running){
       
       break;
     }
   }
     }
     }
     
     
     

     
     
     
   })
    socket.on("draw", function(data) {
      // console.log(data)
      for(let game of data){
        if(game.turn >= game.totalTurns + game.players.length){
            let tempStr =  (rerunArrLength+1) + ". "; 
            for(let i =0;i<game.players.length;i++){
        tempStr += games[ind].players[i].name + " ";
        
      }
      addGame(tempStr);
        }
      }
      
      if(!rollbacking){
        winText.style.display  = "none";
        winText.innerHTML = "";
 let gameToDraw = data[parseInt(selectGame.options[selectGame.selectedIndex].value)];




      if (gameToDraw.running) {
        if(lastCoords != null){
  for (let i = 0; i < gameToDraw.players.length; i++) {
          clear(lastCoords.players[i].pos[0], lastCoords.players[i].pos[1]);
        }
}

lastCoords = gameToDraw;

        time.style.display = "none";
        scoreboard(gameToDraw.players, gameToDraw.bases,  (gameToDraw.turn-gameToDraw.players.length) + "/" + (gameToDraw.totalTurns))
        nodes(gameToDraw.nodes);
        bases(gameToDraw);
          show(gameToDraw)
          // ctx.drawImage(document.getElementById("live"),xSize * 9,0,60,ySize);
        }
      
     
}
    })

    var selectGame = document.getElementById("selectGame");
    selectGame.onchange = function() {
      
      ctx.fillStyle = "white";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      drawGrid();
    }
    
    function scoreboard(players,bases, turnStr){
        document.getElementById("turnStr").innerHTML = "Turn: " + turnStr;
        for (var i = 0; i < players.length; i++) {
          document.getElementById("player" + i).innerHTML = "";
          document.getElementById("player" + i).innerHTML += "Player" + (i+1) + ": <br> energy: " + players[i].energy + "<br> name: " + players[i].name + "<br> base energy: " + bases[i].energy + "<br> ";
        }
    }
    
    
    function checkBase(players, bases){
        for(var i=0;i<players.length;i++){
        if (players[i].pos[1] == bases[i].pos[1] && players[i].pos[0] == bases[i].pos[0]) {
          bases[i].energy += players[i].energy
          players[i].energy = 0;
        }

          for(var j=0;j<players.length;j++){
            if(j != i){
                        if (players[j].pos[1] == bases[i].pos[1] && players[j].pos[0] == bases[i].pos[0]) {
   
          players[j].energy += bases[i].energy
         bases[i].energy= 0;


         
        }
          }
          }
        }
}







function checkNodes(player, nodes){
    for (var i = 0; i < nodes.length; i++) {
        if (player.pos[1] == nodes[i].pos[1] && player.pos[0] == nodes[i].pos[0]) {
          player.energy += nodes[i].energy;
          nodes[i].energy = 0;
        }
      }
}

function checkCollide(players, bases){
  for (var i = 0; i < players.length; i++) {

        for (let j = 0; j < players.length; j++) {

          if (j != i) {
   
            if (players[i].pos[1] == players[j].pos[1] && players[i].pos[0] == players[j].pos[0]) {
              const avg = players[i].energy + players[j].energy;
              if (players[i].energy > players[j].energy) {
                players[i].energy = Math.ceil(avg / 2)
                players[j].energy = Math.floor(avg / 2)
              }
              else if (players[i].energy < players[j].energy) {
                players[j].energy = Math.ceil(avg / 2)
                players[i].energy = Math.floor(avg / 2)
              
            }
            }
            }
          }


        }
        

      
}
    
    
    function displayWinner(color,name,baseEnergy, id){
      winText.style.display = "inline-block";
     winText.innerHTML = "Winner: <span style = 'color: " +  color +  ";'>" + name + "</span>" + " (Player " + (id+1) +")<br>" + name + " won with an astounding base energy score of " + baseEnergy  +"!" 
    }
    
    var globalInstertStr;
    function addGame(str){ //Adds games to the replay selection when they end.
      globalInstertStr= str;

          var htmlCommand = 'socket.emit("rerunGame", parseInt(globalInstertStr.substring(0,globalInstertStr.indexOf(".")))-1);'
let html ="<p onclick = '" + htmlCommand + "'>" +  str + "</p>" ;
         document.getElementById("names").innerHTML= html + document.getElementById("names").innerHTML;
      
      
    }
    
    
  </script>
</body>

</html>
